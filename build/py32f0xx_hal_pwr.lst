ARM GAS  /tmp/ccV0szhS.s 			page 1


   1              		.cpu cortex-m0plus
   2              		.arch armv6s-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"py32f0xx_hal_pwr.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c"
  18              		.section	.text.HAL_PWR_DeInit,"ax",%progbits
  19              		.align	1
  20              		.global	HAL_PWR_DeInit
  21              		.syntax unified
  22              		.code	16
  23              		.thumb_func
  25              	HAL_PWR_DeInit:
  26              	.LFB55:
   1:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
   2:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   ******************************************************************************
   3:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @file    py32f0xx_hal_pwr.c
   4:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @author  MCU Application Team
   5:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief   PWR HAL module driver.
   6:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *          This file provides firmware functions to manage the following
   7:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:
   8:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *           + Initialization/de-initialization functions
   9:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *           + Peripheral Control functions
  10:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *
  11:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   ******************************************************************************
  12:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @attention
  13:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *
  14:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * <h2><center>&copy; Copyright (c) Puya Semiconductor Co.
  15:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * All rights reserved.</center></h2>
  16:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *
  17:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
  18:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * All rights reserved.</center></h2>
  19:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *
  20:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * This software component is licensed by ST under BSD 3-Clause license,
  21:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * the "License"; You may not use this file except in compliance with the
  22:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * License. You may obtain a copy of the License at:
  23:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *                        opensource.org/licenses/BSD-3-Clause
  24:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *
  25:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   ******************************************************************************
  26:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
  27:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
  28:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /* Includes ------------------------------------------------------------------*/
  29:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** #include "py32f0xx_hal.h"
  30:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
  31:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /** @addtogroup PY32F0xx_HAL_Driver
  32:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @{
ARM GAS  /tmp/ccV0szhS.s 			page 2


  33:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
  34:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
  35:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /** @addtogroup PWR
  36:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @{
  37:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
  38:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
  39:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** #ifdef HAL_PWR_MODULE_ENABLED
  40:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
  41:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  42:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /* Private define ------------------------------------------------------------*/
  43:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /** @defgroup PWR_Private_Defines PWR Private Defines
  44:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @{
  45:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
  46:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
  47:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** #if defined(PWR_PVD_SUPPORT)
  48:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask
  49:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @{
  50:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
  51:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** #define PVD_MODE_IT           0x00010000U  /*!< Mask for interruption yielded
  52:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                                                 by PVD threshold crossing     */
  53:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** #define PVD_MODE_EVT          0x00020000U  /*!< Mask for event yielded
  54:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                                                 by PVD threshold crossing     */
  55:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** #define PVD_RISING_EDGE       0x00000001U  /*!< Mask for rising edge set as
  56:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                                                 PVD trigger                   */
  57:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** #define PVD_FALLING_EDGE      0x00000002U  /*!< Mask for falling edge set as
  58:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                                                 PVD trigger                   */
  59:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
  60:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @}
  61:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
  62:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** #endif
  63:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
  64:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
  65:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @}
  66:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
  67:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
  68:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /* Private macro -------------------------------------------------------------*/
  69:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /* Private variables ---------------------------------------------------------*/
  70:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /* Private function prototypes -----------------------------------------------*/
  71:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /* Exported functions --------------------------------------------------------*/
  72:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /** @addtogroup PWR_Exported_Functions  PWR Exported Functions
  73:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @{
  74:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
  75:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
  76:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /** @addtogroup PWR_Exported_Functions_Group1  Initialization and de-initialization functions
  77:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Initialization and de-initialization functions
  78:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *
  79:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** @verbatim
  80:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****  ===============================================================================
  81:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****               ##### Initialization and de-initialization functions #####
  82:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****  ===============================================================================
  83:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     [..]
  84:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
  85:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** @endverbatim
  86:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @{
  87:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
  88:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
  89:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
ARM GAS  /tmp/ccV0szhS.s 			page 3


  90:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Deinitialize the HAL PWR peripheral registers to their default reset
  91:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****             values.
  92:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
  93:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
  94:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_DeInit(void)
  95:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
  27              		.loc 1 95 1 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  96:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   __HAL_RCC_PWR_FORCE_RESET();
  32              		.loc 1 96 3 view .LVU1
  33 0000 054B     		ldr	r3, .L2
  34 0002 D96A     		ldr	r1, [r3, #44]
  35 0004 8022     		movs	r2, #128
  36 0006 5205     		lsls	r2, r2, #21
  37 0008 0A43     		orrs	r2, r1
  38 000a DA62     		str	r2, [r3, #44]
  97:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   __HAL_RCC_PWR_RELEASE_RESET();
  39              		.loc 1 97 3 view .LVU2
  40 000c DA6A     		ldr	r2, [r3, #44]
  41 000e 0349     		ldr	r1, .L2+4
  42 0010 0A40     		ands	r2, r1
  43 0012 DA62     		str	r2, [r3, #44]
  98:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
  44              		.loc 1 98 1 is_stmt 0 view .LVU3
  45              		@ sp needed
  46 0014 7047     		bx	lr
  47              	.L3:
  48 0016 C046     		.align	2
  49              	.L2:
  50 0018 00100240 		.word	1073876992
  51 001c FFFFFFEF 		.word	-268435457
  52              		.cfi_endproc
  53              	.LFE55:
  55              		.section	.text.HAL_PWR_EnableBkUpAccess,"ax",%progbits
  56              		.align	1
  57              		.global	HAL_PWR_EnableBkUpAccess
  58              		.syntax unified
  59              		.code	16
  60              		.thumb_func
  62              	HAL_PWR_EnableBkUpAccess:
  63              	.LFB56:
  99:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 100:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 101:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @}
 102:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 103:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 104:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /** @addtogroup PWR_Exported_Functions_Group2  Peripheral Control functions
 105:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *  @brief Low Power modes configuration functions
 106:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *
 107:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** @verbatim
 108:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 109:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****  ===============================================================================
 110:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                  ##### Peripheral Control functions #####
 111:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****  ===============================================================================
ARM GAS  /tmp/ccV0szhS.s 			page 4


 112:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 113:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     [..]
 114:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****      *** PVD configuration ***
 115:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     =========================
 116:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     [..]
 117:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) The PVD is used to monitor the VDD power supply by comparing it to a
 118:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           threshold selected by the PVD Level (PVDT[2:0]bits in PWR CR2 register).
 119:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) PVDO flag is available to indicate if VDD/VDDA is higher or lower
 120:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           than the PVD threshold. This event is internally connected to the EXTI
 121:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           line 16 and can generate an interrupt if enabled.
 122:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) The PVD is stopped in Standby mode.
 123:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 124:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     *** WakeUp pin configuration ***
 125:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     ================================
 126:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     [..]
 127:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) WakeUp pins are used to wakeup the system from Standby mode or
 128:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           Shutdown mode. WakeUp pins polarity can be set to configure event
 129:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           detection on high level (rising edge) or low level (falling edge).
 130:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 131:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     *** Low Power mode configuration ***
 132:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     =====================================
 133:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     [..]
 134:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       The devices feature 7 low-power modes:
 135:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) Low-power run mode: core and peripherals are running at low frequency.
 136:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           Regulator is in low power mode.
 137:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) Sleep mode: Cortex-M0+ core stopped, peripherals kept running,
 138:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           regulator is main mode.
 139:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) Low-power Sleep mode: Cortex-M0+ core stopped, peripherals kept running
 140:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           and regulator in low power mode.
 141:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) Stop 0 mode: all clocks are stopped except LSI and LSE, regulator is
 142:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****            main mode.
 143:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) Stop 1 mode: all clocks are stopped except LSI and LSE, main regulator
 144:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           off, low power regulator on.
 145:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 146:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****    *** Low-power run mode ***
 147:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****    ==========================
 148:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     [..]
 149:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) Entry: (from main run mode)
 150:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) set LPR bit with HAL_PWREx_EnableLowPowerRunMode() API after
 151:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                having decreased the system clock below 2 MHz.
 152:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) Exit:
 153:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) clear LPR bit then wait for REGLPF bit to be reset with
 154:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                HAL_PWREx_DisableLowPowerRunMode() API. Only then can the
 155:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                system clock frequency be increased above 2 MHz.
 156:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 157:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****    *** Sleep mode / Low-power sleep mode ***
 158:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****    =========================================
 159:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     [..]
 160:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) Entry:
 161:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           The Sleep & Low-power Sleep modes are entered through
 162:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           HAL_PWR_EnterSLEEPMode() API specifying whether or not the regulator
 163:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           is forced to low-power mode and if exit is interrupt or event
 164:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           triggered.
 165:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) PWR_MAINREGULATOR_ON: Sleep mode (regulator in main mode).
 166:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) PWR_LOWPOWERREGULATOR_ON: Low-power Sleep mode (regulator in low
 167:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                power mode). In this case, the system clock frequency must have
 168:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                been decreased below 2 MHz beforehand.
ARM GAS  /tmp/ccV0szhS.s 			page 5


 169:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFI: Core enters sleep mode with WFI instruction
 170:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFE: Core enters sleep mode with WFE instruction
 171:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) WFI Exit:
 172:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****         (++) Any interrupt enabled in nested vectored interrupt controller (NVIC)
 173:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) WFE Exit:
 174:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****         (++) Any wakeup event if cortex is configured with SEVONPEND = 0
 175:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****         (++) Interrupt even when disabled in NVIC if cortex is configured with
 176:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****              SEVONPEND = 1
 177:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     [..]  When exiting the Low-power Sleep mode by issuing an interrupt or a wakeup event,
 178:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           the MCU is in Low-power Run mode.
 179:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 180:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****    *** Stop 0 & Stop 1 modes ***
 181:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****    =============================
 182:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     [..]
 183:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) Entry:
 184:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           The Stop modes are entered through the following APIs:
 185:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) HAL_PWR_EnterSTOPMode() with following settings:
 186:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****               (+++) PWR_MAINREGULATOR_ON to enter STOP0 mode.
 187:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****               (+++) PWR_LOWPOWERREGULATOR_ON to enter STOP1 mode.
 188:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) Exit (interrupt or event-triggered, specified when entering STOP mode):
 189:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) PWR_STOPENTRY_WFI: enter Stop mode with WFI instruction
 190:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) PWR_STOPENTRY_WFE: enter Stop mode with WFE instruction
 191:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) WFI Exit:
 192:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) Any EXTI line (internal or external) configured in interrupt mode
 193:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                with corresponding interrupt enable in NVIC
 194:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****       (+) WFE Exit:
 195:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) Any EXTI line (internal or external) configured in event mode if
 196:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                cortex is configured with SEVONPEND = 0
 197:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           (++) Any EXTI line configured in interrupt mode (even if the
 198:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                corresponding EXTI Interrupt vector is disabled in the NVIC) if
 199:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                cortex is configured with SEVONPEND = 0. The interrupt source can
 200:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                be external interrupts or peripherals with wakeup capability.
 201:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     [..]  When exiting Stop, the MCU is either in Run mode or in Low-power Run mode
 202:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****           depending on the LPR bit setting.
 203:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 204:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 205:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** @endverbatim
 206:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @{
 207:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 208:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 209:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 210:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Enable access to the backup domain
 211:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         (RTC & TAMP registers, backup registers, RCC BDCR register).
 212:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   After reset, the backup domain is protected against
 213:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         possible unwanted write accesses. All RTC & TAMP registers (backup
 214:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         registers included) and RCC BDCR register are concerned.
 215:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 216:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 217:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_EnableBkUpAccess(void)
 218:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
  64              		.loc 1 218 1 is_stmt 1 view -0
  65              		.cfi_startproc
  66              		@ args = 0, pretend = 0, frame = 0
  67              		@ frame_needed = 0, uses_anonymous_args = 0
  68              		@ link register save eliminated.
 219:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   SET_BIT(PWR->CR1, PWR_CR1_DBP);
  69              		.loc 1 219 3 view .LVU5
ARM GAS  /tmp/ccV0szhS.s 			page 6


  70 0000 034A     		ldr	r2, .L5
  71 0002 1168     		ldr	r1, [r2]
  72 0004 8023     		movs	r3, #128
  73 0006 5B00     		lsls	r3, r3, #1
  74 0008 0B43     		orrs	r3, r1
  75 000a 1360     		str	r3, [r2]
 220:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
  76              		.loc 1 220 1 is_stmt 0 view .LVU6
  77              		@ sp needed
  78 000c 7047     		bx	lr
  79              	.L6:
  80 000e C046     		.align	2
  81              	.L5:
  82 0010 00700040 		.word	1073770496
  83              		.cfi_endproc
  84              	.LFE56:
  86              		.section	.text.HAL_PWR_DisableBkUpAccess,"ax",%progbits
  87              		.align	1
  88              		.global	HAL_PWR_DisableBkUpAccess
  89              		.syntax unified
  90              		.code	16
  91              		.thumb_func
  93              	HAL_PWR_DisableBkUpAccess:
  94              	.LFB57:
 221:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 222:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 223:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 224:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Disable access to the backup domain
 225:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 226:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 227:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_DisableBkUpAccess(void)
 228:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
  95              		.loc 1 228 1 is_stmt 1 view -0
  96              		.cfi_startproc
  97              		@ args = 0, pretend = 0, frame = 0
  98              		@ frame_needed = 0, uses_anonymous_args = 0
  99              		@ link register save eliminated.
 229:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   CLEAR_BIT(PWR->CR1, PWR_CR1_DBP);
 100              		.loc 1 229 3 view .LVU8
 101 0000 024A     		ldr	r2, .L8
 102 0002 1368     		ldr	r3, [r2]
 103 0004 0249     		ldr	r1, .L8+4
 104 0006 0B40     		ands	r3, r1
 105 0008 1360     		str	r3, [r2]
 230:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 106              		.loc 1 230 1 is_stmt 0 view .LVU9
 107              		@ sp needed
 108 000a 7047     		bx	lr
 109              	.L9:
 110              		.align	2
 111              	.L8:
 112 000c 00700040 		.word	1073770496
 113 0010 FFFEFFFF 		.word	-257
 114              		.cfi_endproc
 115              	.LFE57:
 117              		.section	.text.HAL_PWR_ConfigPVD,"ax",%progbits
 118              		.align	1
ARM GAS  /tmp/ccV0szhS.s 			page 7


 119              		.global	HAL_PWR_ConfigPVD
 120              		.syntax unified
 121              		.code	16
 122              		.thumb_func
 124              	HAL_PWR_ConfigPVD:
 125              	.LVL0:
 126              	.LFB58:
 231:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 232:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 233:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** #if defined(PWR_PVD_SUPPORT)
 234:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 235:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Configure the Power Voltage Detector (PVD).
 236:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @param  sConfigPVD pointer to a PWR_PVDTypeDef structure that contains the
 237:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****             PVD configuration information: threshold levels, operating mode.
 238:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   Refer to the electrical characteristics of your device datasheet for
 239:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         more details about the voltage thresholds corresponding to each
 240:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         detection level.
 241:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   User should take care that rising threshold is higher than falling
 242:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         one in order to avoid having always PVDO output set.
 243:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval HAL_OK
 244:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 245:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** HAL_StatusTypeDef HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
 246:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 127              		.loc 1 246 1 is_stmt 1 view -0
 128              		.cfi_startproc
 129              		@ args = 0, pretend = 0, frame = 0
 130              		@ frame_needed = 0, uses_anonymous_args = 0
 131              		.loc 1 246 1 is_stmt 0 view .LVU11
 132 0000 10B5     		push	{r4, lr}
 133              	.LCFI0:
 134              		.cfi_def_cfa_offset 8
 135              		.cfi_offset 4, -8
 136              		.cfi_offset 14, -4
 247:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Check the parameters */
 248:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
 137              		.loc 1 248 3 is_stmt 1 view .LVU12
 249:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
 138              		.loc 1 249 3 view .LVU13
 250:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 251:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Set PVD level bits only according to PVDLevel value */
 252:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   MODIFY_REG(PWR->CR2, (PWR_CR2_PVDT | PWR_CR2_FLTEN | PWR_CR2_FLT_TIME | PWR_CR2_SRCSEL), \
 139              		.loc 1 252 3 view .LVU14
 140 0002 2149     		ldr	r1, .L19
 141 0004 4B68     		ldr	r3, [r1, #4]
 142 0006 214A     		ldr	r2, .L19+4
 143 0008 1340     		ands	r3, r2
 144 000a 8268     		ldr	r2, [r0, #8]
 145 000c 4468     		ldr	r4, [r0, #4]
 146 000e 2243     		orrs	r2, r4
 147 0010 0468     		ldr	r4, [r0]
 148 0012 2243     		orrs	r2, r4
 149 0014 1343     		orrs	r3, r2
 150 0016 4B60     		str	r3, [r1, #4]
 253:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                        (sConfigPVD->PVDLevel | sConfigPVD->PVDFilter | sConfigPVD->PVDSource));
 254:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 255:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Clear any previous config, in case no event or IT mode is selected */
 256:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
ARM GAS  /tmp/ccV0szhS.s 			page 8


 151              		.loc 1 256 3 view .LVU15
 152 0018 1D4B     		ldr	r3, .L19+8
 153 001a 8424     		movs	r4, #132
 154 001c 1959     		ldr	r1, [r3, r4]
 155 001e 1D4A     		ldr	r2, .L19+12
 156 0020 1140     		ands	r1, r2
 157 0022 1951     		str	r1, [r3, r4]
 257:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_IT();
 158              		.loc 1 257 3 view .LVU16
 159 0024 043C     		subs	r4, r4, #4
 160 0026 1959     		ldr	r1, [r3, r4]
 161 0028 1140     		ands	r1, r2
 162 002a 1951     		str	r1, [r3, r4]
 258:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE();
 163              		.loc 1 258 3 view .LVU17
 164 002c 5968     		ldr	r1, [r3, #4]
 165 002e 1140     		ands	r1, r2
 166 0030 5960     		str	r1, [r3, #4]
 259:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
 167              		.loc 1 259 3 view .LVU18
 168 0032 1968     		ldr	r1, [r3]
 169 0034 0A40     		ands	r2, r1
 170 0036 1A60     		str	r2, [r3]
 260:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 261:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Configure interrupt mode */
 262:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
 171              		.loc 1 262 3 view .LVU19
 172              		.loc 1 262 17 is_stmt 0 view .LVU20
 173 0038 C368     		ldr	r3, [r0, #12]
 174              		.loc 1 262 5 view .LVU21
 175 003a DB03     		lsls	r3, r3, #15
 176 003c 06D5     		bpl	.L11
 263:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 264:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_IT();
 177              		.loc 1 264 5 is_stmt 1 view .LVU22
 178 003e 1449     		ldr	r1, .L19+8
 179 0040 8022     		movs	r2, #128
 180 0042 8C58     		ldr	r4, [r1, r2]
 181 0044 8023     		movs	r3, #128
 182 0046 5B02     		lsls	r3, r3, #9
 183 0048 2343     		orrs	r3, r4
 184 004a 8B50     		str	r3, [r1, r2]
 185              	.L11:
 265:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 266:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 267:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Configure event mode */
 268:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
 186              		.loc 1 268 3 view .LVU23
 187              		.loc 1 268 17 is_stmt 0 view .LVU24
 188 004c C368     		ldr	r3, [r0, #12]
 189              		.loc 1 268 5 view .LVU25
 190 004e 9B03     		lsls	r3, r3, #14
 191 0050 06D5     		bpl	.L12
 269:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 270:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
 192              		.loc 1 270 5 is_stmt 1 view .LVU26
 193 0052 0F49     		ldr	r1, .L19+8
ARM GAS  /tmp/ccV0szhS.s 			page 9


 194 0054 8422     		movs	r2, #132
 195 0056 8C58     		ldr	r4, [r1, r2]
 196 0058 8023     		movs	r3, #128
 197 005a 5B02     		lsls	r3, r3, #9
 198 005c 2343     		orrs	r3, r4
 199 005e 8B50     		str	r3, [r1, r2]
 200              	.L12:
 271:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 272:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 273:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Configure the edge */
 274:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
 201              		.loc 1 274 3 view .LVU27
 202              		.loc 1 274 17 is_stmt 0 view .LVU28
 203 0060 C368     		ldr	r3, [r0, #12]
 204              		.loc 1 274 5 view .LVU29
 205 0062 DB07     		lsls	r3, r3, #31
 206 0064 05D5     		bpl	.L13
 275:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 276:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
 207              		.loc 1 276 5 is_stmt 1 view .LVU30
 208 0066 0A4A     		ldr	r2, .L19+8
 209 0068 1168     		ldr	r1, [r2]
 210 006a 8023     		movs	r3, #128
 211 006c 5B02     		lsls	r3, r3, #9
 212 006e 0B43     		orrs	r3, r1
 213 0070 1360     		str	r3, [r2]
 214              	.L13:
 277:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 278:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 279:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
 215              		.loc 1 279 3 view .LVU31
 216              		.loc 1 279 17 is_stmt 0 view .LVU32
 217 0072 C368     		ldr	r3, [r0, #12]
 218              		.loc 1 279 5 view .LVU33
 219 0074 9B07     		lsls	r3, r3, #30
 220 0076 05D5     		bpl	.L14
 280:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 281:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
 221              		.loc 1 281 5 is_stmt 1 view .LVU34
 222 0078 054A     		ldr	r2, .L19+8
 223 007a 5168     		ldr	r1, [r2, #4]
 224 007c 8023     		movs	r3, #128
 225 007e 5B02     		lsls	r3, r3, #9
 226 0080 0B43     		orrs	r3, r1
 227 0082 5360     		str	r3, [r2, #4]
 228              	.L14:
 282:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 283:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 284:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   return HAL_OK;
 229              		.loc 1 284 3 view .LVU35
 285:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 230              		.loc 1 285 1 is_stmt 0 view .LVU36
 231 0084 0020     		movs	r0, #0
 232              	.LVL1:
 233              		.loc 1 285 1 view .LVU37
 234              		@ sp needed
 235 0086 10BD     		pop	{r4, pc}
ARM GAS  /tmp/ccV0szhS.s 			page 10


 236              	.L20:
 237              		.align	2
 238              	.L19:
 239 0088 00700040 		.word	1073770496
 240 008c 8BF0FFFF 		.word	-3957
 241 0090 00180240 		.word	1073879040
 242 0094 FFFFFEFF 		.word	-65537
 243              		.cfi_endproc
 244              	.LFE58:
 246              		.section	.text.HAL_PWR_EnablePVD,"ax",%progbits
 247              		.align	1
 248              		.global	HAL_PWR_EnablePVD
 249              		.syntax unified
 250              		.code	16
 251              		.thumb_func
 253              	HAL_PWR_EnablePVD:
 254              	.LFB59:
 286:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 287:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 288:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 289:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Enable the Power Voltage Detector (PVD).
 290:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 291:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 292:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_EnablePVD(void)
 293:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 255              		.loc 1 293 1 is_stmt 1 view -0
 256              		.cfi_startproc
 257              		@ args = 0, pretend = 0, frame = 0
 258              		@ frame_needed = 0, uses_anonymous_args = 0
 259              		@ link register save eliminated.
 294:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   SET_BIT(PWR->CR2, PWR_CR2_PVDE);
 260              		.loc 1 294 3 view .LVU39
 261 0000 024A     		ldr	r2, .L22
 262 0002 5368     		ldr	r3, [r2, #4]
 263 0004 0121     		movs	r1, #1
 264 0006 0B43     		orrs	r3, r1
 265 0008 5360     		str	r3, [r2, #4]
 295:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 266              		.loc 1 295 1 is_stmt 0 view .LVU40
 267              		@ sp needed
 268 000a 7047     		bx	lr
 269              	.L23:
 270              		.align	2
 271              	.L22:
 272 000c 00700040 		.word	1073770496
 273              		.cfi_endproc
 274              	.LFE59:
 276              		.section	.text.HAL_PWR_DisablePVD,"ax",%progbits
 277              		.align	1
 278              		.global	HAL_PWR_DisablePVD
 279              		.syntax unified
 280              		.code	16
 281              		.thumb_func
 283              	HAL_PWR_DisablePVD:
 284              	.LFB60:
 296:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 297:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
ARM GAS  /tmp/ccV0szhS.s 			page 11


 298:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 299:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Disable the Power Voltage Detector (PVD).
 300:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 301:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 302:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_DisablePVD(void)
 303:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 285              		.loc 1 303 1 is_stmt 1 view -0
 286              		.cfi_startproc
 287              		@ args = 0, pretend = 0, frame = 0
 288              		@ frame_needed = 0, uses_anonymous_args = 0
 289              		@ link register save eliminated.
 304:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   CLEAR_BIT(PWR->CR2, PWR_CR2_PVDE);
 290              		.loc 1 304 3 view .LVU42
 291 0000 024A     		ldr	r2, .L25
 292 0002 5368     		ldr	r3, [r2, #4]
 293 0004 0121     		movs	r1, #1
 294 0006 8B43     		bics	r3, r1
 295 0008 5360     		str	r3, [r2, #4]
 305:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 296              		.loc 1 305 1 is_stmt 0 view .LVU43
 297              		@ sp needed
 298 000a 7047     		bx	lr
 299              	.L26:
 300              		.align	2
 301              	.L25:
 302 000c 00700040 		.word	1073770496
 303              		.cfi_endproc
 304              	.LFE60:
 306              		.section	.text.HAL_PWR_ConfigStopMode,"ax",%progbits
 307              		.align	1
 308              		.global	HAL_PWR_ConfigStopMode
 309              		.syntax unified
 310              		.code	16
 311              		.thumb_func
 313              	HAL_PWR_ConfigStopMode:
 314              	.LVL2:
 315              	.LFB61:
 306:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** #endif
 307:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 308:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 309:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Configure LPR voltage,sram retention voltage,and wakeup correlation
 310:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****             timing in Sto mode.
 311:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @param  sStopModeConfig pointer to a PWR_StopModeConfigTypeDef structure that
 312:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****             contains the Stop mode configuration information.
 313:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval HAL_OK
 314:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 315:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** HAL_StatusTypeDef HAL_PWR_ConfigStopMode(PWR_StopModeConfigTypeDef *sStopModeConfig)
 316:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 316              		.loc 1 316 1 is_stmt 1 view -0
 317              		.cfi_startproc
 318              		@ args = 0, pretend = 0, frame = 0
 319              		@ frame_needed = 0, uses_anonymous_args = 0
 320              		.loc 1 316 1 is_stmt 0 view .LVU45
 321 0000 10B5     		push	{r4, lr}
 322              	.LCFI1:
 323              		.cfi_def_cfa_offset 8
 324              		.cfi_offset 4, -8
ARM GAS  /tmp/ccV0szhS.s 			page 12


 325              		.cfi_offset 14, -4
 317:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Check the parameters */
 318:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   assert_param(IS_PWR_STOP_LPR_VOLT(sStopModeConfig->LPVoltSelection));
 326              		.loc 1 318 3 is_stmt 1 view .LVU46
 319:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   assert_param(IS_PWR_REGULATOR_SWTICH_DELAY(sStopModeConfig->RegulatorSwitchDelay));
 327              		.loc 1 319 3 view .LVU47
 320:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_HSIEN_TIMING(sStopModeConfig->WakeUpHsiEnableTime));
 328              		.loc 1 320 3 view .LVU48
 321:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   assert_param(IS_PWR_SRAM_RETENTION_VOLT(sStopModeConfig->SramRetentionVolt));
 329              		.loc 1 321 3 view .LVU49
 322:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_FLASH_DELAY(sStopModeConfig->FlashDelay));
 330              		.loc 1 322 3 view .LVU50
 323:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 324:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Set the STOP mode and STOP wake-up timing related configurations */
 325:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   MODIFY_REG(PWR->CR1, (PWR_CR1_VOS | PWR_CR1_MRRDY_TIME | PWR_CR1_HSION_CTRL | PWR_CR1_SRAM_RETV |
 331              		.loc 1 325 3 view .LVU51
 332 0002 0749     		ldr	r1, .L28
 333 0004 0B68     		ldr	r3, [r1]
 334 0006 074A     		ldr	r2, .L28+4
 335 0008 1A40     		ands	r2, r3
 336 000a 0368     		ldr	r3, [r0]
 337 000c 4468     		ldr	r4, [r0, #4]
 338 000e 2343     		orrs	r3, r4
 339 0010 C468     		ldr	r4, [r0, #12]
 340 0012 2343     		orrs	r3, r4
 341 0014 0069     		ldr	r0, [r0, #16]
 342              	.LVL3:
 343              		.loc 1 325 3 is_stmt 0 view .LVU52
 344 0016 0343     		orrs	r3, r0
 345 0018 1343     		orrs	r3, r2
 346 001a 0B60     		str	r3, [r1]
 326:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                        (sStopModeConfig->LPVoltSelection) | \
 327:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                        (sStopModeConfig->RegulatorSwitchDelay) | \
 328:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                        (sStopModeConfig->SramRetentionVolt) | \
 329:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                        (sStopModeConfig->FlashDelay));
 330:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 331:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   return HAL_OK;
 347              		.loc 1 331 3 is_stmt 1 view .LVU53
 332:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 348              		.loc 1 332 1 is_stmt 0 view .LVU54
 349 001c 0020     		movs	r0, #0
 350              		@ sp needed
 351 001e 10BD     		pop	{r4, pc}
 352              	.L29:
 353              		.align	2
 354              	.L28:
 355 0020 00700040 		.word	1073770496
 356 0024 FFF1F0FF 		.word	-986625
 357              		.cfi_endproc
 358              	.LFE61:
 360              		.section	.text.HAL_PWR_ConfigBIAS,"ax",%progbits
 361              		.align	1
 362              		.global	HAL_PWR_ConfigBIAS
 363              		.syntax unified
 364              		.code	16
 365              		.thumb_func
 367              	HAL_PWR_ConfigBIAS:
ARM GAS  /tmp/ccV0szhS.s 			page 13


 368              	.LVL4:
 369              	.LFB62:
 333:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 334:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 335:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Configure the bias current load source and bias current values.
 336:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @param  sBIASConfig pointer to a PWR_BIASConfigTypeDef structure that
 337:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****             contains the bias current configuration information.
 338:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval HAL_OK
 339:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 340:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** HAL_StatusTypeDef HAL_PWR_ConfigBIAS(PWR_BIASConfigTypeDef *sBIASConfig)
 341:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 370              		.loc 1 341 1 is_stmt 1 view -0
 371              		.cfi_startproc
 372              		@ args = 0, pretend = 0, frame = 0
 373              		@ frame_needed = 0, uses_anonymous_args = 0
 374              		.loc 1 341 1 is_stmt 0 view .LVU56
 375 0000 10B5     		push	{r4, lr}
 376              	.LCFI2:
 377              		.cfi_def_cfa_offset 8
 378              		.cfi_offset 4, -8
 379              		.cfi_offset 14, -4
 342:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Check the parameters */
 343:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   assert_param(IS_BIAS_CURRENTS_SOURCE(sBIASConfig->BiasCurrentSource));
 380              		.loc 1 343 3 is_stmt 1 view .LVU57
 344:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   
 345:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   if(((sBIASConfig->BiasCurrentSource) & PWR_BIAS_CURRENTS_FROM_BIAS_CR) == PWR_BIAS_CURRENTS_FROM_
 381              		.loc 1 345 3 view .LVU58
 382              		.loc 1 345 19 is_stmt 0 view .LVU59
 383 0002 0368     		ldr	r3, [r0]
 384              		.loc 1 345 5 view .LVU60
 385 0004 DA06     		lsls	r2, r3, #27
 386 0006 09D5     		bpl	.L31
 346:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 347:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     /* Set the bias currents load source and bias currents value*/
 348:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     MODIFY_REG(PWR->CR1, (PWR_CR1_BIAS_CR_SEL) | (PWR_CR1_BIAS_CR), (sBIASConfig->BiasCurrentSource
 387              		.loc 1 348 5 is_stmt 1 view .LVU61
 388 0008 0849     		ldr	r1, .L33
 389 000a 0A68     		ldr	r2, [r1]
 390 000c 1F24     		movs	r4, #31
 391 000e A243     		bics	r2, r4
 392 0010 4068     		ldr	r0, [r0, #4]
 393              	.LVL5:
 394              		.loc 1 348 5 is_stmt 0 view .LVU62
 395 0012 0343     		orrs	r3, r0
 396 0014 1343     		orrs	r3, r2
 397 0016 0B60     		str	r3, [r1]
 398              	.L32:
 349:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****                                                                     (sBIASConfig->BiasCurrentValue)
 350:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 351:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   else
 352:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 353:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     /* Set the bias currents load source */
 354:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     MODIFY_REG(PWR->CR1, PWR_CR1_BIAS_CR_SEL, (sBIASConfig->BiasCurrentSource));
 355:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 356:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   return HAL_OK;
 399              		.loc 1 356 3 is_stmt 1 view .LVU63
 357:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
ARM GAS  /tmp/ccV0szhS.s 			page 14


 400              		.loc 1 357 1 is_stmt 0 view .LVU64
 401 0018 0020     		movs	r0, #0
 402              		@ sp needed
 403 001a 10BD     		pop	{r4, pc}
 404              	.LVL6:
 405              	.L31:
 354:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 406              		.loc 1 354 5 is_stmt 1 view .LVU65
 407 001c 0349     		ldr	r1, .L33
 408 001e 0A68     		ldr	r2, [r1]
 409 0020 1020     		movs	r0, #16
 410              	.LVL7:
 354:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 411              		.loc 1 354 5 is_stmt 0 view .LVU66
 412 0022 8243     		bics	r2, r0
 413 0024 1343     		orrs	r3, r2
 414 0026 0B60     		str	r3, [r1]
 415 0028 F6E7     		b	.L32
 416              	.L34:
 417 002a C046     		.align	2
 418              	.L33:
 419 002c 00700040 		.word	1073770496
 420              		.cfi_endproc
 421              	.LFE62:
 423              		.section	.text.HAL_PWR_EnterSLEEPMode,"ax",%progbits
 424              		.align	1
 425              		.global	HAL_PWR_EnterSLEEPMode
 426              		.syntax unified
 427              		.code	16
 428              		.thumb_func
 430              	HAL_PWR_EnterSLEEPMode:
 431              	.LVL8:
 432              	.LFB63:
 358:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 359:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 360:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Enter Sleep or Low-power Sleep mode.
 361:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   In Sleep/Low-power Sleep mode, all I/O pins keep the same state as
 362:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         in Run mode.
 363:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @param  SLEEPEntry Specifies if Sleep mode is entered with WFI or WFE
 364:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         instruction. This parameter can be one of the following values:
 365:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *           @arg @ref PWR_SLEEPENTRY_WFI enter Sleep or Low-power Sleep
 366:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *                     mode with WFI instruction
 367:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *           @arg @ref PWR_SLEEPENTRY_WFE enter Sleep or Low-power Sleep
 368:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *                     mode with WFE instruction
 369:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   When WFI entry is used, tick interrupt have to be disabled if not
 370:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         desired as the interrupt wake up source.
 371:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 372:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 373:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_EnterSLEEPMode(uint8_t SLEEPEntry)
 374:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 433              		.loc 1 374 1 is_stmt 1 view -0
 434              		.cfi_startproc
 435              		@ args = 0, pretend = 0, frame = 0
 436              		@ frame_needed = 0, uses_anonymous_args = 0
 437              		@ link register save eliminated.
 375:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Check the parameters */
 376:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
ARM GAS  /tmp/ccV0szhS.s 			page 15


 438              		.loc 1 376 3 view .LVU68
 377:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 378:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Clear SLEEPDEEP bit of Cortex System Control Register */
 379:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 439              		.loc 1 379 3 view .LVU69
 440 0000 064A     		ldr	r2, .L39
 441 0002 1369     		ldr	r3, [r2, #16]
 442 0004 0421     		movs	r1, #4
 443 0006 8B43     		bics	r3, r1
 444 0008 1361     		str	r3, [r2, #16]
 380:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 381:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Select SLEEP mode entry -------------------------------------------------*/
 382:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 445              		.loc 1 382 3 view .LVU70
 446              		.loc 1 382 5 is_stmt 0 view .LVU71
 447 000a 0128     		cmp	r0, #1
 448 000c 03D0     		beq	.L38
 383:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 384:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 385:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __WFI();
 386:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 387:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   else
 388:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 389:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     /* Request Wait For Event */
 390:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __SEV();
 449              		.loc 1 390 5 is_stmt 1 view .LVU72
 450              	.LBB18:
 451              	.LBI18:
 452              		.file 2 "CMSIS/Include/cmsis_gcc.h"
   1:CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS Cortex-M Core Function/Instruction Header File
   4:CMSIS/Include/cmsis_gcc.h ****  * @version  V4.30
   5:CMSIS/Include/cmsis_gcc.h ****  * @date     20. October 2015
   6:CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:CMSIS/Include/cmsis_gcc.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:CMSIS/Include/cmsis_gcc.h **** 
   9:CMSIS/Include/cmsis_gcc.h ****    All rights reserved.
  10:CMSIS/Include/cmsis_gcc.h ****    Redistribution and use in source and binary forms, with or without
  11:CMSIS/Include/cmsis_gcc.h ****    modification, are permitted provided that the following conditions are met:
  12:CMSIS/Include/cmsis_gcc.h ****    - Redistributions of source code must retain the above copyright
  13:CMSIS/Include/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer.
  14:CMSIS/Include/cmsis_gcc.h ****    - Redistributions in binary form must reproduce the above copyright
  15:CMSIS/Include/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer in the
  16:CMSIS/Include/cmsis_gcc.h ****      documentation and/or other materials provided with the distribution.
  17:CMSIS/Include/cmsis_gcc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:CMSIS/Include/cmsis_gcc.h ****      to endorse or promote products derived from this software without
  19:CMSIS/Include/cmsis_gcc.h ****      specific prior written permission.
  20:CMSIS/Include/cmsis_gcc.h ****    *
  21:CMSIS/Include/cmsis_gcc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:CMSIS/Include/cmsis_gcc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:CMSIS/Include/cmsis_gcc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:CMSIS/Include/cmsis_gcc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:CMSIS/Include/cmsis_gcc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:CMSIS/Include/cmsis_gcc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:CMSIS/Include/cmsis_gcc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:CMSIS/Include/cmsis_gcc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
ARM GAS  /tmp/ccV0szhS.s 			page 16


  29:CMSIS/Include/cmsis_gcc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:CMSIS/Include/cmsis_gcc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:CMSIS/Include/cmsis_gcc.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:CMSIS/Include/cmsis_gcc.h ****    ---------------------------------------------------------------------------*/
  33:CMSIS/Include/cmsis_gcc.h **** 
  34:CMSIS/Include/cmsis_gcc.h **** 
  35:CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  36:CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  37:CMSIS/Include/cmsis_gcc.h **** 
  38:CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  39:CMSIS/Include/cmsis_gcc.h **** #if defined ( __GNUC__ )
  40:CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  41:CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  42:CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  43:CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  44:CMSIS/Include/cmsis_gcc.h **** #endif
  45:CMSIS/Include/cmsis_gcc.h **** 
  46:CMSIS/Include/cmsis_gcc.h **** 
  47:CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  48:CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  49:CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  50:CMSIS/Include/cmsis_gcc.h ****   @{
  51:CMSIS/Include/cmsis_gcc.h ****  */
  52:CMSIS/Include/cmsis_gcc.h **** 
  53:CMSIS/Include/cmsis_gcc.h **** /**
  54:CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  55:CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  56:CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  57:CMSIS/Include/cmsis_gcc.h ****  */
  58:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
  59:CMSIS/Include/cmsis_gcc.h **** {
  60:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  61:CMSIS/Include/cmsis_gcc.h **** }
  62:CMSIS/Include/cmsis_gcc.h **** 
  63:CMSIS/Include/cmsis_gcc.h **** 
  64:CMSIS/Include/cmsis_gcc.h **** /**
  65:CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  66:CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  67:CMSIS/Include/cmsis_gcc.h ****   Can only be executed in Privileged modes.
  68:CMSIS/Include/cmsis_gcc.h ****  */
  69:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
  70:CMSIS/Include/cmsis_gcc.h **** {
  71:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  72:CMSIS/Include/cmsis_gcc.h **** }
  73:CMSIS/Include/cmsis_gcc.h **** 
  74:CMSIS/Include/cmsis_gcc.h **** 
  75:CMSIS/Include/cmsis_gcc.h **** /**
  76:CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
  77:CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
  78:CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
  79:CMSIS/Include/cmsis_gcc.h ****  */
  80:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
  81:CMSIS/Include/cmsis_gcc.h **** {
  82:CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
  83:CMSIS/Include/cmsis_gcc.h **** 
  84:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
  85:CMSIS/Include/cmsis_gcc.h ****   return(result);
ARM GAS  /tmp/ccV0szhS.s 			page 17


  86:CMSIS/Include/cmsis_gcc.h **** }
  87:CMSIS/Include/cmsis_gcc.h **** 
  88:CMSIS/Include/cmsis_gcc.h **** 
  89:CMSIS/Include/cmsis_gcc.h **** /**
  90:CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
  91:CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
  92:CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
  93:CMSIS/Include/cmsis_gcc.h ****  */
  94:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
  95:CMSIS/Include/cmsis_gcc.h **** {
  96:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  97:CMSIS/Include/cmsis_gcc.h **** }
  98:CMSIS/Include/cmsis_gcc.h **** 
  99:CMSIS/Include/cmsis_gcc.h **** 
 100:CMSIS/Include/cmsis_gcc.h **** /**
 101:CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 102:CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 103:CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 104:CMSIS/Include/cmsis_gcc.h ****  */
 105:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
 106:CMSIS/Include/cmsis_gcc.h **** {
 107:CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 108:CMSIS/Include/cmsis_gcc.h **** 
 109:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 110:CMSIS/Include/cmsis_gcc.h ****   return(result);
 111:CMSIS/Include/cmsis_gcc.h **** }
 112:CMSIS/Include/cmsis_gcc.h **** 
 113:CMSIS/Include/cmsis_gcc.h **** 
 114:CMSIS/Include/cmsis_gcc.h **** /**
 115:CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 116:CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 117:CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 118:CMSIS/Include/cmsis_gcc.h ****  */
 119:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
 120:CMSIS/Include/cmsis_gcc.h **** {
 121:CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 122:CMSIS/Include/cmsis_gcc.h **** 
 123:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 124:CMSIS/Include/cmsis_gcc.h ****   return(result);
 125:CMSIS/Include/cmsis_gcc.h **** }
 126:CMSIS/Include/cmsis_gcc.h **** 
 127:CMSIS/Include/cmsis_gcc.h **** 
 128:CMSIS/Include/cmsis_gcc.h **** /**
 129:CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 130:CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 131:CMSIS/Include/cmsis_gcc.h **** 
 132:CMSIS/Include/cmsis_gcc.h ****     \return               xPSR Register value
 133:CMSIS/Include/cmsis_gcc.h ****  */
 134:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
 135:CMSIS/Include/cmsis_gcc.h **** {
 136:CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 137:CMSIS/Include/cmsis_gcc.h **** 
 138:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 139:CMSIS/Include/cmsis_gcc.h ****   return(result);
 140:CMSIS/Include/cmsis_gcc.h **** }
 141:CMSIS/Include/cmsis_gcc.h **** 
 142:CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccV0szhS.s 			page 18


 143:CMSIS/Include/cmsis_gcc.h **** /**
 144:CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 145:CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 146:CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 147:CMSIS/Include/cmsis_gcc.h ****  */
 148:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
 149:CMSIS/Include/cmsis_gcc.h **** {
 150:CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 151:CMSIS/Include/cmsis_gcc.h **** 
 152:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 153:CMSIS/Include/cmsis_gcc.h ****   return(result);
 154:CMSIS/Include/cmsis_gcc.h **** }
 155:CMSIS/Include/cmsis_gcc.h **** 
 156:CMSIS/Include/cmsis_gcc.h **** 
 157:CMSIS/Include/cmsis_gcc.h **** /**
 158:CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 159:CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 160:CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 161:CMSIS/Include/cmsis_gcc.h ****  */
 162:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 163:CMSIS/Include/cmsis_gcc.h **** {
 164:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 165:CMSIS/Include/cmsis_gcc.h **** }
 166:CMSIS/Include/cmsis_gcc.h **** 
 167:CMSIS/Include/cmsis_gcc.h **** 
 168:CMSIS/Include/cmsis_gcc.h **** /**
 169:CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 170:CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 171:CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 172:CMSIS/Include/cmsis_gcc.h ****  */
 173:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
 174:CMSIS/Include/cmsis_gcc.h **** {
 175:CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 176:CMSIS/Include/cmsis_gcc.h **** 
 177:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 178:CMSIS/Include/cmsis_gcc.h ****   return(result);
 179:CMSIS/Include/cmsis_gcc.h **** }
 180:CMSIS/Include/cmsis_gcc.h **** 
 181:CMSIS/Include/cmsis_gcc.h **** 
 182:CMSIS/Include/cmsis_gcc.h **** /**
 183:CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 184:CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 185:CMSIS/Include/cmsis_gcc.h **** 
 186:CMSIS/Include/cmsis_gcc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 187:CMSIS/Include/cmsis_gcc.h ****  */
 188:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 189:CMSIS/Include/cmsis_gcc.h **** {
 190:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 191:CMSIS/Include/cmsis_gcc.h **** }
 192:CMSIS/Include/cmsis_gcc.h **** 
 193:CMSIS/Include/cmsis_gcc.h **** 
 194:CMSIS/Include/cmsis_gcc.h **** /**
 195:CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 196:CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 197:CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 198:CMSIS/Include/cmsis_gcc.h ****  */
 199:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
ARM GAS  /tmp/ccV0szhS.s 			page 19


 200:CMSIS/Include/cmsis_gcc.h **** {
 201:CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 202:CMSIS/Include/cmsis_gcc.h **** 
 203:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 204:CMSIS/Include/cmsis_gcc.h ****   return(result);
 205:CMSIS/Include/cmsis_gcc.h **** }
 206:CMSIS/Include/cmsis_gcc.h **** 
 207:CMSIS/Include/cmsis_gcc.h **** 
 208:CMSIS/Include/cmsis_gcc.h **** /**
 209:CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 210:CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 211:CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 212:CMSIS/Include/cmsis_gcc.h ****  */
 213:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 214:CMSIS/Include/cmsis_gcc.h **** {
 215:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 216:CMSIS/Include/cmsis_gcc.h **** }
 217:CMSIS/Include/cmsis_gcc.h **** 
 218:CMSIS/Include/cmsis_gcc.h **** 
 219:CMSIS/Include/cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U)
 220:CMSIS/Include/cmsis_gcc.h **** 
 221:CMSIS/Include/cmsis_gcc.h **** /**
 222:CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 223:CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 224:CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 225:CMSIS/Include/cmsis_gcc.h ****  */
 226:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
 227:CMSIS/Include/cmsis_gcc.h **** {
 228:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 229:CMSIS/Include/cmsis_gcc.h **** }
 230:CMSIS/Include/cmsis_gcc.h **** 
 231:CMSIS/Include/cmsis_gcc.h **** 
 232:CMSIS/Include/cmsis_gcc.h **** /**
 233:CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 234:CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 235:CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 236:CMSIS/Include/cmsis_gcc.h ****  */
 237:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
 238:CMSIS/Include/cmsis_gcc.h **** {
 239:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 240:CMSIS/Include/cmsis_gcc.h **** }
 241:CMSIS/Include/cmsis_gcc.h **** 
 242:CMSIS/Include/cmsis_gcc.h **** 
 243:CMSIS/Include/cmsis_gcc.h **** /**
 244:CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 245:CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 246:CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 247:CMSIS/Include/cmsis_gcc.h ****  */
 248:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 249:CMSIS/Include/cmsis_gcc.h **** {
 250:CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 251:CMSIS/Include/cmsis_gcc.h **** 
 252:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 253:CMSIS/Include/cmsis_gcc.h ****   return(result);
 254:CMSIS/Include/cmsis_gcc.h **** }
 255:CMSIS/Include/cmsis_gcc.h **** 
 256:CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccV0szhS.s 			page 20


 257:CMSIS/Include/cmsis_gcc.h **** /**
 258:CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 259:CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 260:CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 261:CMSIS/Include/cmsis_gcc.h ****  */
 262:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
 263:CMSIS/Include/cmsis_gcc.h **** {
 264:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 265:CMSIS/Include/cmsis_gcc.h **** }
 266:CMSIS/Include/cmsis_gcc.h **** 
 267:CMSIS/Include/cmsis_gcc.h **** 
 268:CMSIS/Include/cmsis_gcc.h **** /**
 269:CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 270:CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 271:CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 272:CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 273:CMSIS/Include/cmsis_gcc.h ****  */
 274:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
 275:CMSIS/Include/cmsis_gcc.h **** {
 276:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
 277:CMSIS/Include/cmsis_gcc.h **** }
 278:CMSIS/Include/cmsis_gcc.h **** 
 279:CMSIS/Include/cmsis_gcc.h **** 
 280:CMSIS/Include/cmsis_gcc.h **** /**
 281:CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 282:CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 283:CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 284:CMSIS/Include/cmsis_gcc.h ****  */
 285:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 286:CMSIS/Include/cmsis_gcc.h **** {
 287:CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 288:CMSIS/Include/cmsis_gcc.h **** 
 289:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 290:CMSIS/Include/cmsis_gcc.h ****   return(result);
 291:CMSIS/Include/cmsis_gcc.h **** }
 292:CMSIS/Include/cmsis_gcc.h **** 
 293:CMSIS/Include/cmsis_gcc.h **** 
 294:CMSIS/Include/cmsis_gcc.h **** /**
 295:CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 296:CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 297:CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 298:CMSIS/Include/cmsis_gcc.h ****  */
 299:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 300:CMSIS/Include/cmsis_gcc.h **** {
 301:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 302:CMSIS/Include/cmsis_gcc.h **** }
 303:CMSIS/Include/cmsis_gcc.h **** 
 304:CMSIS/Include/cmsis_gcc.h **** #endif /* (__CORTEX_M >= 0x03U) */
 305:CMSIS/Include/cmsis_gcc.h **** 
 306:CMSIS/Include/cmsis_gcc.h **** 
 307:CMSIS/Include/cmsis_gcc.h **** #if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
 308:CMSIS/Include/cmsis_gcc.h **** 
 309:CMSIS/Include/cmsis_gcc.h **** /**
 310:CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 311:CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 312:CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 313:CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccV0szhS.s 			page 21


 314:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
 315:CMSIS/Include/cmsis_gcc.h **** {
 316:CMSIS/Include/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 317:CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 318:CMSIS/Include/cmsis_gcc.h **** 
 319:CMSIS/Include/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 320:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 321:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 322:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 323:CMSIS/Include/cmsis_gcc.h ****   return(result);
 324:CMSIS/Include/cmsis_gcc.h **** #else
 325:CMSIS/Include/cmsis_gcc.h ****    return(0);
 326:CMSIS/Include/cmsis_gcc.h **** #endif
 327:CMSIS/Include/cmsis_gcc.h **** }
 328:CMSIS/Include/cmsis_gcc.h **** 
 329:CMSIS/Include/cmsis_gcc.h **** 
 330:CMSIS/Include/cmsis_gcc.h **** /**
 331:CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 332:CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 333:CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 334:CMSIS/Include/cmsis_gcc.h ****  */
 335:CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 336:CMSIS/Include/cmsis_gcc.h **** {
 337:CMSIS/Include/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 338:CMSIS/Include/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 339:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 340:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
 341:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 342:CMSIS/Include/cmsis_gcc.h **** #endif
 343:CMSIS/Include/cmsis_gcc.h **** }
 344:CMSIS/Include/cmsis_gcc.h **** 
 345:CMSIS/Include/cmsis_gcc.h **** #endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
 346:CMSIS/Include/cmsis_gcc.h **** 
 347:CMSIS/Include/cmsis_gcc.h **** 
 348:CMSIS/Include/cmsis_gcc.h **** 
 349:CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 350:CMSIS/Include/cmsis_gcc.h **** 
 351:CMSIS/Include/cmsis_gcc.h **** 
 352:CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 353:CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 354:CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 355:CMSIS/Include/cmsis_gcc.h ****   @{
 356:CMSIS/Include/cmsis_gcc.h **** */
 357:CMSIS/Include/cmsis_gcc.h **** 
 358:CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 359:CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 360:CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 361:CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 362:CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 363:CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 364:CMSIS/Include/cmsis_gcc.h **** #else
 365:CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 366:CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 367:CMSIS/Include/cmsis_gcc.h **** #endif
 368:CMSIS/Include/cmsis_gcc.h **** 
 369:CMSIS/Include/cmsis_gcc.h **** /**
 370:CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
ARM GAS  /tmp/ccV0szhS.s 			page 22


 371:CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 372:CMSIS/Include/cmsis_gcc.h ****  */
 373:CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 374:CMSIS/Include/cmsis_gcc.h **** {
 375:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("nop");
 376:CMSIS/Include/cmsis_gcc.h **** }
 377:CMSIS/Include/cmsis_gcc.h **** 
 378:CMSIS/Include/cmsis_gcc.h **** 
 379:CMSIS/Include/cmsis_gcc.h **** /**
 380:CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 381:CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 382:CMSIS/Include/cmsis_gcc.h ****  */
 383:CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 384:CMSIS/Include/cmsis_gcc.h **** {
 385:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("wfi");
 386:CMSIS/Include/cmsis_gcc.h **** }
 387:CMSIS/Include/cmsis_gcc.h **** 
 388:CMSIS/Include/cmsis_gcc.h **** 
 389:CMSIS/Include/cmsis_gcc.h **** /**
 390:CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 391:CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 392:CMSIS/Include/cmsis_gcc.h ****     a low-power state until one of a number of events occurs.
 393:CMSIS/Include/cmsis_gcc.h ****  */
 394:CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 395:CMSIS/Include/cmsis_gcc.h **** {
 396:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("wfe");
 397:CMSIS/Include/cmsis_gcc.h **** }
 398:CMSIS/Include/cmsis_gcc.h **** 
 399:CMSIS/Include/cmsis_gcc.h **** 
 400:CMSIS/Include/cmsis_gcc.h **** /**
 401:CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 402:CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 403:CMSIS/Include/cmsis_gcc.h ****  */
 404:CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 453              		.loc 2 404 53 view .LVU73
 454              	.LBB19:
 405:CMSIS/Include/cmsis_gcc.h **** {
 406:CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("sev");
 455              		.loc 2 406 3 view .LVU74
 456              		.syntax divided
 457              	@ 406 "CMSIS/Include/cmsis_gcc.h" 1
 458 000e 40BF     		sev
 459              	@ 0 "" 2
 460              		.thumb
 461              		.syntax unified
 462              	.LBE19:
 463              	.LBE18:
 391:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __WFE();
 464              		.loc 1 391 5 view .LVU75
 465              	.LBB20:
 466              	.LBI20:
 394:CMSIS/Include/cmsis_gcc.h **** {
 467              		.loc 2 394 53 view .LVU76
 468              	.LBB21:
 396:CMSIS/Include/cmsis_gcc.h **** }
 469              		.loc 2 396 3 view .LVU77
 470              		.syntax divided
ARM GAS  /tmp/ccV0szhS.s 			page 23


 471              	@ 396 "CMSIS/Include/cmsis_gcc.h" 1
 472 0010 20BF     		wfe
 473              	@ 0 "" 2
 474              		.thumb
 475              		.syntax unified
 476              	.LBE21:
 477              	.LBE20:
 392:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __WFE();
 478              		.loc 1 392 5 view .LVU78
 479              	.LBB22:
 480              	.LBI22:
 394:CMSIS/Include/cmsis_gcc.h **** {
 481              		.loc 2 394 53 view .LVU79
 482              	.LBB23:
 396:CMSIS/Include/cmsis_gcc.h **** }
 483              		.loc 2 396 3 view .LVU80
 484              		.syntax divided
 485              	@ 396 "CMSIS/Include/cmsis_gcc.h" 1
 486 0012 20BF     		wfe
 487              	@ 0 "" 2
 488              		.thumb
 489              		.syntax unified
 490              	.L35:
 491              	.LBE23:
 492              	.LBE22:
 393:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 394:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 493              		.loc 1 394 1 is_stmt 0 view .LVU81
 494              		@ sp needed
 495 0014 7047     		bx	lr
 496              	.L38:
 385:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 497              		.loc 1 385 5 is_stmt 1 view .LVU82
 498              	.LBB24:
 499              	.LBI24:
 383:CMSIS/Include/cmsis_gcc.h **** {
 500              		.loc 2 383 53 view .LVU83
 501              	.LBB25:
 385:CMSIS/Include/cmsis_gcc.h **** }
 502              		.loc 2 385 3 view .LVU84
 503              		.syntax divided
 504              	@ 385 "CMSIS/Include/cmsis_gcc.h" 1
 505 0016 30BF     		wfi
 506              	@ 0 "" 2
 386:CMSIS/Include/cmsis_gcc.h **** 
 507              		.loc 2 386 1 is_stmt 0 view .LVU85
 508              		.thumb
 509              		.syntax unified
 510 0018 FCE7     		b	.L35
 511              	.L40:
 512 001a C046     		.align	2
 513              	.L39:
 514 001c 00ED00E0 		.word	-536810240
 515              	.LBE25:
 516              	.LBE24:
 517              		.cfi_endproc
 518              	.LFE63:
ARM GAS  /tmp/ccV0szhS.s 			page 24


 520              		.section	.text.HAL_PWR_EnterSTOPMode,"ax",%progbits
 521              		.align	1
 522              		.global	HAL_PWR_EnterSTOPMode
 523              		.syntax unified
 524              		.code	16
 525              		.thumb_func
 527              	HAL_PWR_EnterSTOPMode:
 528              	.LVL9:
 529              	.LFB64:
 395:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 396:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 397:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 398:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Enter Stop mode
 399:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   This API is named HAL_PWR_EnterSTOPMode to ensure compatibility with
 400:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         legacy code running on devices where only "Stop mode" is mentioned
 401:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         with main or low power regulator ON.
 402:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
 403:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   All clocks in the VCORE domain are stopped; the PLL, the HSI and the
 404:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         HSE oscillators are disabled. Some peripherals with the wakeup
 405:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         capability can switch on the HSI to receive a frame, and switch off
 406:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         the HSI after receiving the frame if it is not a wakeup frame.
 407:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         SRAM and register contents are preserved.
 408:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         The BOR is available.
 409:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         The voltage regulator can be configured either in normal (Stop 0) or
 410:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         low-power mode (Stop 1).
 411:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   When exiting Stop 0 or Stop 1 mode by issuing an interrupt or a
 412:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         wakeup event, the HSI RC oscillator is selected as system clock
 413:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   When the voltage regulator operates in low power mode (Stop 1),
 414:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         an additional startup delay is incurred when waking up. By keeping
 415:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         the internal regulator ON during Stop mode (Stop 0), the consumption
 416:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         is higher although the startup time is reduced.
 417:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @param  Regulator Specifies the regulator state in Stop mode
 418:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         This parameter can be one of the following values:
 419:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *            @arg @ref PWR_MAINREGULATOR_ON  Stop 0 mode (main regulator ON)
 420:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *            @arg @ref PWR_LOWPOWERREGULATOR_ON  Stop 1 mode (low power
 421:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *                                                regulator ON)
 422:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @param  STOPEntry Specifies Stop 0 or Stop 1 mode is entered with WFI or
 423:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         WFE instruction. This parameter can be one of the following values:
 424:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *            @arg @ref PWR_STOPENTRY_WFI  Enter Stop 0 or Stop 1 mode with WFI
 425:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *                                         instruction.
 426:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *            @arg @ref PWR_STOPENTRY_WFE  Enter Stop 0 or Stop 1 mode with WFE
 427:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *                                         instruction.
 428:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 429:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 430:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
 431:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 530              		.loc 1 431 1 is_stmt 1 view -0
 531              		.cfi_startproc
 532              		@ args = 0, pretend = 0, frame = 0
 533              		@ frame_needed = 0, uses_anonymous_args = 0
 534              		@ link register save eliminated.
 432:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Check the parameters */
 433:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   assert_param(IS_PWR_REGULATOR(Regulator));
 535              		.loc 1 433 3 view .LVU87
 434:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
 536              		.loc 1 434 3 view .LVU88
 435:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
ARM GAS  /tmp/ccV0szhS.s 			page 25


 436:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   if (Regulator != PWR_MAINREGULATOR_ON)
 537              		.loc 1 436 3 view .LVU89
 538              		.loc 1 436 6 is_stmt 0 view .LVU90
 539 0000 0028     		cmp	r0, #0
 540 0002 15D0     		beq	.L42
 437:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 438:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     /* Stop mode with Low-Power Regulator */
 439:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     SET_BIT(PWR->CR1,PWR_CR1_LPR);
 541              		.loc 1 439 5 is_stmt 1 view .LVU91
 542 0004 0E4A     		ldr	r2, .L47
 543 0006 1068     		ldr	r0, [r2]
 544              	.LVL10:
 545              		.loc 1 439 5 is_stmt 0 view .LVU92
 546 0008 8023     		movs	r3, #128
 547 000a DB01     		lsls	r3, r3, #7
 548 000c 0343     		orrs	r3, r0
 549 000e 1360     		str	r3, [r2]
 550              	.L43:
 440:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 441:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   else
 442:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 443:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     /* Stop mode with Main Regulator */
 444:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     CLEAR_BIT(PWR->CR1,PWR_CR1_LPR);
 445:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 446:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 447:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 448:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 551              		.loc 1 448 3 is_stmt 1 view .LVU93
 552 0010 0C4A     		ldr	r2, .L47+4
 553 0012 1369     		ldr	r3, [r2, #16]
 554 0014 0420     		movs	r0, #4
 555 0016 0343     		orrs	r3, r0
 556 0018 1361     		str	r3, [r2, #16]
 449:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 450:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Select Stop mode entry --------------------------------------------------*/
 451:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   if(STOPEntry == PWR_STOPENTRY_WFI)
 557              		.loc 1 451 3 view .LVU94
 558              		.loc 1 451 5 is_stmt 0 view .LVU95
 559 001a 0129     		cmp	r1, #1
 560 001c 0ED0     		beq	.L46
 452:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 453:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 454:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __WFI();
 455:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 456:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   else
 457:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 458:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     /* Request Wait For Event */
 459:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __SEV();
 561              		.loc 1 459 5 is_stmt 1 view .LVU96
 562              	.LBB26:
 563              	.LBI26:
 404:CMSIS/Include/cmsis_gcc.h **** {
 564              		.loc 2 404 53 view .LVU97
 565              	.LBB27:
 566              		.loc 2 406 3 view .LVU98
 567              		.syntax divided
 568              	@ 406 "CMSIS/Include/cmsis_gcc.h" 1
ARM GAS  /tmp/ccV0szhS.s 			page 26


 569 001e 40BF     		sev
 570              	@ 0 "" 2
 571              		.thumb
 572              		.syntax unified
 573              	.LBE27:
 574              	.LBE26:
 460:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __WFE();
 575              		.loc 1 460 5 view .LVU99
 576              	.LBB28:
 577              	.LBI28:
 394:CMSIS/Include/cmsis_gcc.h **** {
 578              		.loc 2 394 53 view .LVU100
 579              	.LBB29:
 396:CMSIS/Include/cmsis_gcc.h **** }
 580              		.loc 2 396 3 view .LVU101
 581              		.syntax divided
 582              	@ 396 "CMSIS/Include/cmsis_gcc.h" 1
 583 0020 20BF     		wfe
 584              	@ 0 "" 2
 585              		.thumb
 586              		.syntax unified
 587              	.LBE29:
 588              	.LBE28:
 461:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __WFE();
 589              		.loc 1 461 5 view .LVU102
 590              	.LBB30:
 591              	.LBI30:
 394:CMSIS/Include/cmsis_gcc.h **** {
 592              		.loc 2 394 53 view .LVU103
 593              	.LBB31:
 396:CMSIS/Include/cmsis_gcc.h **** }
 594              		.loc 2 396 3 view .LVU104
 595              		.syntax divided
 596              	@ 396 "CMSIS/Include/cmsis_gcc.h" 1
 597 0022 20BF     		wfe
 598              	@ 0 "" 2
 599              		.thumb
 600              		.syntax unified
 601              	.L45:
 602              	.LBE31:
 603              	.LBE30:
 462:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 463:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 464:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 465:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 604              		.loc 1 465 3 view .LVU105
 605 0024 074A     		ldr	r2, .L47+4
 606 0026 1369     		ldr	r3, [r2, #16]
 607 0028 0421     		movs	r1, #4
 608              	.LVL11:
 609              		.loc 1 465 3 is_stmt 0 view .LVU106
 610 002a 8B43     		bics	r3, r1
 611 002c 1361     		str	r3, [r2, #16]
 466:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 612              		.loc 1 466 1 view .LVU107
 613              		@ sp needed
 614 002e 7047     		bx	lr
ARM GAS  /tmp/ccV0szhS.s 			page 27


 615              	.LVL12:
 616              	.L42:
 444:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 617              		.loc 1 444 5 is_stmt 1 view .LVU108
 618 0030 034A     		ldr	r2, .L47
 619 0032 1368     		ldr	r3, [r2]
 620 0034 0448     		ldr	r0, .L47+8
 621              	.LVL13:
 444:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 622              		.loc 1 444 5 is_stmt 0 view .LVU109
 623 0036 0340     		ands	r3, r0
 624 0038 1360     		str	r3, [r2]
 625 003a E9E7     		b	.L43
 626              	.L46:
 454:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 627              		.loc 1 454 5 is_stmt 1 view .LVU110
 628              	.LBB32:
 629              	.LBI32:
 383:CMSIS/Include/cmsis_gcc.h **** {
 630              		.loc 2 383 53 view .LVU111
 631              	.LBB33:
 385:CMSIS/Include/cmsis_gcc.h **** }
 632              		.loc 2 385 3 view .LVU112
 633              		.syntax divided
 634              	@ 385 "CMSIS/Include/cmsis_gcc.h" 1
 635 003c 30BF     		wfi
 636              	@ 0 "" 2
 386:CMSIS/Include/cmsis_gcc.h **** 
 637              		.loc 2 386 1 is_stmt 0 view .LVU113
 638              		.thumb
 639              		.syntax unified
 640 003e F1E7     		b	.L45
 641              	.L48:
 642              		.align	2
 643              	.L47:
 644 0040 00700040 		.word	1073770496
 645 0044 00ED00E0 		.word	-536810240
 646 0048 FFBFFFFF 		.word	-16385
 647              	.LBE33:
 648              	.LBE32:
 649              		.cfi_endproc
 650              	.LFE64:
 652              		.section	.text.HAL_PWR_EnableSleepOnExit,"ax",%progbits
 653              		.align	1
 654              		.global	HAL_PWR_EnableSleepOnExit
 655              		.syntax unified
 656              		.code	16
 657              		.thumb_func
 659              	HAL_PWR_EnableSleepOnExit:
 660              	.LFB65:
 467:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 468:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 469:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 470:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 471:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Enable Sleep-On-Exit Cortex feature
 472:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   Set SLEEPONEXIT bit of SCR register. When this bit is set, the
 473:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         processor enters SLEEP or DEEPSLEEP mode when an interruption
ARM GAS  /tmp/ccV0szhS.s 			page 28


 474:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         handling is over returning to thread mode. Setting this bit is
 475:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         useful when the processor is expected to run only on interruptions
 476:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         handling.
 477:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 478:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 479:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_EnableSleepOnExit(void)
 480:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 661              		.loc 1 480 1 is_stmt 1 view -0
 662              		.cfi_startproc
 663              		@ args = 0, pretend = 0, frame = 0
 664              		@ frame_needed = 0, uses_anonymous_args = 0
 665              		@ link register save eliminated.
 481:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Set SLEEPONEXIT bit of Cortex System Control Register */
 482:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 666              		.loc 1 482 3 view .LVU115
 667 0000 024A     		ldr	r2, .L50
 668 0002 1369     		ldr	r3, [r2, #16]
 669 0004 0221     		movs	r1, #2
 670 0006 0B43     		orrs	r3, r1
 671 0008 1361     		str	r3, [r2, #16]
 483:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 672              		.loc 1 483 1 is_stmt 0 view .LVU116
 673              		@ sp needed
 674 000a 7047     		bx	lr
 675              	.L51:
 676              		.align	2
 677              	.L50:
 678 000c 00ED00E0 		.word	-536810240
 679              		.cfi_endproc
 680              	.LFE65:
 682              		.section	.text.HAL_PWR_DisableSleepOnExit,"ax",%progbits
 683              		.align	1
 684              		.global	HAL_PWR_DisableSleepOnExit
 685              		.syntax unified
 686              		.code	16
 687              		.thumb_func
 689              	HAL_PWR_DisableSleepOnExit:
 690              	.LFB66:
 484:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 485:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 486:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 487:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Disable Sleep-On-Exit Cortex feature
 488:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   Clear SLEEPONEXIT bit of SCR register. When this bit is set, the
 489:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         processor enters SLEEP or DEEPSLEEP mode when an interruption
 490:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         handling is over.
 491:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 492:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 493:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_DisableSleepOnExit(void)
 494:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 691              		.loc 1 494 1 is_stmt 1 view -0
 692              		.cfi_startproc
 693              		@ args = 0, pretend = 0, frame = 0
 694              		@ frame_needed = 0, uses_anonymous_args = 0
 695              		@ link register save eliminated.
 495:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Clear SLEEPONEXIT bit of Cortex System Control Register */
 496:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 696              		.loc 1 496 3 view .LVU118
ARM GAS  /tmp/ccV0szhS.s 			page 29


 697 0000 024A     		ldr	r2, .L53
 698 0002 1369     		ldr	r3, [r2, #16]
 699 0004 0221     		movs	r1, #2
 700 0006 8B43     		bics	r3, r1
 701 0008 1361     		str	r3, [r2, #16]
 497:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 702              		.loc 1 497 1 is_stmt 0 view .LVU119
 703              		@ sp needed
 704 000a 7047     		bx	lr
 705              	.L54:
 706              		.align	2
 707              	.L53:
 708 000c 00ED00E0 		.word	-536810240
 709              		.cfi_endproc
 710              	.LFE66:
 712              		.section	.text.HAL_PWR_EnableSEVOnPend,"ax",%progbits
 713              		.align	1
 714              		.global	HAL_PWR_EnableSEVOnPend
 715              		.syntax unified
 716              		.code	16
 717              		.thumb_func
 719              	HAL_PWR_EnableSEVOnPend:
 720              	.LFB67:
 498:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 499:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 500:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 501:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Enable Cortex Sev On Pending feature.
 502:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   Set SEVONPEND bit of SCR register. When this bit is set, enabled
 503:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         events and all interrupts, including disabled ones can wakeup
 504:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         processor from WFE.
 505:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 506:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 507:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_EnableSEVOnPend(void)
 508:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 721              		.loc 1 508 1 is_stmt 1 view -0
 722              		.cfi_startproc
 723              		@ args = 0, pretend = 0, frame = 0
 724              		@ frame_needed = 0, uses_anonymous_args = 0
 725              		@ link register save eliminated.
 509:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Set SEVONPEND bit of Cortex System Control Register */
 510:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 726              		.loc 1 510 3 view .LVU121
 727 0000 024A     		ldr	r2, .L56
 728 0002 1369     		ldr	r3, [r2, #16]
 729 0004 1021     		movs	r1, #16
 730 0006 0B43     		orrs	r3, r1
 731 0008 1361     		str	r3, [r2, #16]
 511:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 732              		.loc 1 511 1 is_stmt 0 view .LVU122
 733              		@ sp needed
 734 000a 7047     		bx	lr
 735              	.L57:
 736              		.align	2
 737              	.L56:
 738 000c 00ED00E0 		.word	-536810240
 739              		.cfi_endproc
 740              	.LFE67:
ARM GAS  /tmp/ccV0szhS.s 			page 30


 742              		.section	.text.HAL_PWR_DisableSEVOnPend,"ax",%progbits
 743              		.align	1
 744              		.global	HAL_PWR_DisableSEVOnPend
 745              		.syntax unified
 746              		.code	16
 747              		.thumb_func
 749              	HAL_PWR_DisableSEVOnPend:
 750              	.LFB68:
 512:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 513:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 514:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 515:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  Disable Cortex Sev On Pending feature.
 516:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   Clear SEVONPEND bit of SCR register. When this bit is clear, only
 517:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   *         enable interrupts or events can wakeup processor from WFE
 518:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 519:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 520:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_DisableSEVOnPend(void)
 521:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 751              		.loc 1 521 1 is_stmt 1 view -0
 752              		.cfi_startproc
 753              		@ args = 0, pretend = 0, frame = 0
 754              		@ frame_needed = 0, uses_anonymous_args = 0
 755              		@ link register save eliminated.
 522:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Clear SEVONPEND bit of Cortex System Control Register */
 523:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 756              		.loc 1 523 3 view .LVU124
 757 0000 024A     		ldr	r2, .L59
 758 0002 1369     		ldr	r3, [r2, #16]
 759 0004 1021     		movs	r1, #16
 760 0006 8B43     		bics	r3, r1
 761 0008 1361     		str	r3, [r2, #16]
 524:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 762              		.loc 1 524 1 is_stmt 0 view .LVU125
 763              		@ sp needed
 764 000a 7047     		bx	lr
 765              	.L60:
 766              		.align	2
 767              	.L59:
 768 000c 00ED00E0 		.word	-536810240
 769              		.cfi_endproc
 770              	.LFE68:
 772              		.section	.text.HAL_PWR_PVD_Callback,"ax",%progbits
 773              		.align	1
 774              		.weak	HAL_PWR_PVD_Callback
 775              		.syntax unified
 776              		.code	16
 777              		.thumb_func
 779              	HAL_PWR_PVD_Callback:
 780              	.LFB70:
 525:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 526:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** #if defined(PWR_PVD_SUPPORT)
 527:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 528:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  This function handles the PWR PVD interrupt request.
 529:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @note   This API should be called under the PVD_IRQHandler().
 530:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 531:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 532:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** void HAL_PWR_PVD_IRQHandler(void)
ARM GAS  /tmp/ccV0szhS.s 			page 31


 533:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 534:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Check PWR exti Rising flag */
 535:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   if(__HAL_PWR_PVD_EXTI_GET_FLAG() != 0x0U)
 536:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 537:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     /* Clear PVD exti pending bit */
 538:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 539:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 540:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     /* PWR PVD interrupt rising user callback */
 541:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****     HAL_PWR_PVD_Callback();
 542:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 543:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 544:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 545:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** /**
 546:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @brief  PWR PVD interrupt callback
 547:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   * @retval None
 548:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 549:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** __weak void HAL_PWR_PVD_Callback(void)
 550:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** {
 781              		.loc 1 550 1 is_stmt 1 view -0
 782              		.cfi_startproc
 783              		@ args = 0, pretend = 0, frame = 0
 784              		@ frame_needed = 0, uses_anonymous_args = 0
 785              		@ link register save eliminated.
 551:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* NOTE : This function should not be modified; when the callback is needed,
 552:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****             the HAL_PWR_PVD_Callback can be implemented in the user file
 553:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   */
 554:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** }
 786              		.loc 1 554 1 view .LVU127
 787              		@ sp needed
 788 0000 7047     		bx	lr
 789              		.cfi_endproc
 790              	.LFE70:
 792              		.section	.text.HAL_PWR_PVD_IRQHandler,"ax",%progbits
 793              		.align	1
 794              		.global	HAL_PWR_PVD_IRQHandler
 795              		.syntax unified
 796              		.code	16
 797              		.thumb_func
 799              	HAL_PWR_PVD_IRQHandler:
 800              	.LFB69:
 533:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   /* Check PWR exti Rising flag */
 801              		.loc 1 533 1 view -0
 802              		.cfi_startproc
 803              		@ args = 0, pretend = 0, frame = 0
 804              		@ frame_needed = 0, uses_anonymous_args = 0
 805 0000 10B5     		push	{r4, lr}
 806              	.LCFI3:
 807              		.cfi_def_cfa_offset 8
 808              		.cfi_offset 4, -8
 809              		.cfi_offset 14, -4
 535:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 810              		.loc 1 535 3 view .LVU129
 535:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
 811              		.loc 1 535 6 is_stmt 0 view .LVU130
 812 0002 064B     		ldr	r3, .L66
 813 0004 DB68     		ldr	r3, [r3, #12]
 535:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   {
ARM GAS  /tmp/ccV0szhS.s 			page 32


 814              		.loc 1 535 5 view .LVU131
 815 0006 DB03     		lsls	r3, r3, #15
 816 0008 00D4     		bmi	.L65
 817              	.L62:
 543:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 818              		.loc 1 543 1 view .LVU132
 819              		@ sp needed
 820 000a 10BD     		pop	{r4, pc}
 821              	.L65:
 538:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 822              		.loc 1 538 5 is_stmt 1 view .LVU133
 823 000c 034B     		ldr	r3, .L66
 824 000e 8022     		movs	r2, #128
 825 0010 5202     		lsls	r2, r2, #9
 826 0012 DA60     		str	r2, [r3, #12]
 541:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c ****   }
 827              		.loc 1 541 5 view .LVU134
 828 0014 FFF7FEFF 		bl	HAL_PWR_PVD_Callback
 829              	.LVL14:
 543:PY32F0xx_HAL_Driver/Src/py32f0xx_hal_pwr.c **** 
 830              		.loc 1 543 1 is_stmt 0 view .LVU135
 831 0018 F7E7     		b	.L62
 832              	.L67:
 833 001a C046     		.align	2
 834              	.L66:
 835 001c 00180240 		.word	1073879040
 836              		.cfi_endproc
 837              	.LFE69:
 839              		.text
 840              	.Letext0:
 841              		.file 3 "/usr/lib/gcc/arm-none-eabi/14.2.1/include/stdint.h"
 842              		.file 4 "CMSIS/Include/core_cm0plus.h"
 843              		.file 5 "CMSIS/Device/PY32F0xx/Include/py32f003x8.h"
 844              		.file 6 "PY32F0xx_HAL_Driver/Inc/py32f0xx_hal_def.h"
 845              		.file 7 "PY32F0xx_HAL_Driver/Inc/py32f0xx_hal_pwr.h"
ARM GAS  /tmp/ccV0szhS.s 			page 33


DEFINED SYMBOLS
                            *ABS*:00000000 py32f0xx_hal_pwr.c
     /tmp/ccV0szhS.s:19     .text.HAL_PWR_DeInit:00000000 $t
     /tmp/ccV0szhS.s:25     .text.HAL_PWR_DeInit:00000000 HAL_PWR_DeInit
     /tmp/ccV0szhS.s:50     .text.HAL_PWR_DeInit:00000018 $d
     /tmp/ccV0szhS.s:56     .text.HAL_PWR_EnableBkUpAccess:00000000 $t
     /tmp/ccV0szhS.s:62     .text.HAL_PWR_EnableBkUpAccess:00000000 HAL_PWR_EnableBkUpAccess
     /tmp/ccV0szhS.s:82     .text.HAL_PWR_EnableBkUpAccess:00000010 $d
     /tmp/ccV0szhS.s:87     .text.HAL_PWR_DisableBkUpAccess:00000000 $t
     /tmp/ccV0szhS.s:93     .text.HAL_PWR_DisableBkUpAccess:00000000 HAL_PWR_DisableBkUpAccess
     /tmp/ccV0szhS.s:112    .text.HAL_PWR_DisableBkUpAccess:0000000c $d
     /tmp/ccV0szhS.s:118    .text.HAL_PWR_ConfigPVD:00000000 $t
     /tmp/ccV0szhS.s:124    .text.HAL_PWR_ConfigPVD:00000000 HAL_PWR_ConfigPVD
     /tmp/ccV0szhS.s:239    .text.HAL_PWR_ConfigPVD:00000088 $d
     /tmp/ccV0szhS.s:247    .text.HAL_PWR_EnablePVD:00000000 $t
     /tmp/ccV0szhS.s:253    .text.HAL_PWR_EnablePVD:00000000 HAL_PWR_EnablePVD
     /tmp/ccV0szhS.s:272    .text.HAL_PWR_EnablePVD:0000000c $d
     /tmp/ccV0szhS.s:277    .text.HAL_PWR_DisablePVD:00000000 $t
     /tmp/ccV0szhS.s:283    .text.HAL_PWR_DisablePVD:00000000 HAL_PWR_DisablePVD
     /tmp/ccV0szhS.s:302    .text.HAL_PWR_DisablePVD:0000000c $d
     /tmp/ccV0szhS.s:307    .text.HAL_PWR_ConfigStopMode:00000000 $t
     /tmp/ccV0szhS.s:313    .text.HAL_PWR_ConfigStopMode:00000000 HAL_PWR_ConfigStopMode
     /tmp/ccV0szhS.s:355    .text.HAL_PWR_ConfigStopMode:00000020 $d
     /tmp/ccV0szhS.s:361    .text.HAL_PWR_ConfigBIAS:00000000 $t
     /tmp/ccV0szhS.s:367    .text.HAL_PWR_ConfigBIAS:00000000 HAL_PWR_ConfigBIAS
     /tmp/ccV0szhS.s:419    .text.HAL_PWR_ConfigBIAS:0000002c $d
     /tmp/ccV0szhS.s:424    .text.HAL_PWR_EnterSLEEPMode:00000000 $t
     /tmp/ccV0szhS.s:430    .text.HAL_PWR_EnterSLEEPMode:00000000 HAL_PWR_EnterSLEEPMode
     /tmp/ccV0szhS.s:514    .text.HAL_PWR_EnterSLEEPMode:0000001c $d
     /tmp/ccV0szhS.s:521    .text.HAL_PWR_EnterSTOPMode:00000000 $t
     /tmp/ccV0szhS.s:527    .text.HAL_PWR_EnterSTOPMode:00000000 HAL_PWR_EnterSTOPMode
     /tmp/ccV0szhS.s:644    .text.HAL_PWR_EnterSTOPMode:00000040 $d
     /tmp/ccV0szhS.s:653    .text.HAL_PWR_EnableSleepOnExit:00000000 $t
     /tmp/ccV0szhS.s:659    .text.HAL_PWR_EnableSleepOnExit:00000000 HAL_PWR_EnableSleepOnExit
     /tmp/ccV0szhS.s:678    .text.HAL_PWR_EnableSleepOnExit:0000000c $d
     /tmp/ccV0szhS.s:683    .text.HAL_PWR_DisableSleepOnExit:00000000 $t
     /tmp/ccV0szhS.s:689    .text.HAL_PWR_DisableSleepOnExit:00000000 HAL_PWR_DisableSleepOnExit
     /tmp/ccV0szhS.s:708    .text.HAL_PWR_DisableSleepOnExit:0000000c $d
     /tmp/ccV0szhS.s:713    .text.HAL_PWR_EnableSEVOnPend:00000000 $t
     /tmp/ccV0szhS.s:719    .text.HAL_PWR_EnableSEVOnPend:00000000 HAL_PWR_EnableSEVOnPend
     /tmp/ccV0szhS.s:738    .text.HAL_PWR_EnableSEVOnPend:0000000c $d
     /tmp/ccV0szhS.s:743    .text.HAL_PWR_DisableSEVOnPend:00000000 $t
     /tmp/ccV0szhS.s:749    .text.HAL_PWR_DisableSEVOnPend:00000000 HAL_PWR_DisableSEVOnPend
     /tmp/ccV0szhS.s:768    .text.HAL_PWR_DisableSEVOnPend:0000000c $d
     /tmp/ccV0szhS.s:773    .text.HAL_PWR_PVD_Callback:00000000 $t
     /tmp/ccV0szhS.s:779    .text.HAL_PWR_PVD_Callback:00000000 HAL_PWR_PVD_Callback
     /tmp/ccV0szhS.s:793    .text.HAL_PWR_PVD_IRQHandler:00000000 $t
     /tmp/ccV0szhS.s:799    .text.HAL_PWR_PVD_IRQHandler:00000000 HAL_PWR_PVD_IRQHandler
     /tmp/ccV0szhS.s:835    .text.HAL_PWR_PVD_IRQHandler:0000001c $d

NO UNDEFINED SYMBOLS
